// Code generated by go generate; DO NOT EDIT.
// Generator version: v3.0.1
package handler

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"math"
	"net/http"
	"reflect"
	"strconv"
	"time"

	"github.com/arfis/waiting-room/nghis-adapter/internal/data/dto"
	"github.com/arfis/waiting-room/nghis-adapter/internal/errors"
	"github.com/go-chi/chi/v5"
	"github.com/go-playground/validator/v10"
)

var (
	validate = validator.New()
)

func GetValidator() *validator.Validate {
	return validate
}

func WriteJson(c context.Context, w http.ResponseWriter, status int, dto any) error {
	b, err := json.Marshal(dto)
	if err != nil {
		return err
	}
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(status)
	_, err = w.Write(b)
	return err
}

func PathParamToString(r *http.Request, param string) string {
	s := chi.URLParam(r, param)
	return s
}

func PathParamToInt64(r *http.Request, param string) (int64, error) {
	parseInt, err := strconv.ParseInt(chi.URLParam(r, param), 10, 64)
	if err != nil {
		return 0, errors.New(errors.BusinessErrorCode, fmt.Sprintf("%s could not be parsed", param), http.StatusBadRequest, nil)
	}
	return parseInt, nil
}

func PathParamToBool(r *http.Request, param string) (bool, error) {
	parseBool, err := strconv.ParseBool(chi.URLParam(r, param))
	if err != nil {
		return false, errors.New(errors.BusinessErrorCode, fmt.Sprintf("%s could not be parsed", param), http.StatusBadRequest, nil)
	}
	return parseBool, nil
}

func PathParamToDateTime(r *http.Request, param string) (time.Time, error) {
	parsedDateTime, err := time.Parse(time.RFC3339, param)
	if err != nil {
		return time.Time{}, errors.New(errors.BusinessErrorCode, fmt.Sprintf("%s could not be parsed", param), http.StatusBadRequest, nil)
	}
	return parsedDateTime, nil
}

func PathParamToInt32(r *http.Request, param string) (int32, error) {
	parseInt, err := strconv.ParseInt(chi.URLParam(r, param), 10, 32)
	if err != nil {
		return 0, errors.New(errors.BusinessErrorCode, fmt.Sprintf("%s could not be parsed", param), http.StatusBadRequest, nil)
	}
	return int32(parseInt), nil
}

func QueryParamToString(r *http.Request, param string) string {
	return r.URL.Query().Get(param)
}

func QueryOptionalParamToString(r *http.Request, param string) *string {
	val := r.URL.Query().Get(param)
	if val == "" {
		return nil
	}
	return &val
}

func QueryParamToArrayString(r *http.Request, param string) []string {
	return r.URL.Query()[param]
}

func QueryParamToBool(r *http.Request, param string) (bool, error) {
	parseBool, err := strconv.ParseBool(r.URL.Query().Get(param))
	if err != nil {
		return false, errors.New(errors.BusinessErrorCode, fmt.Sprintf("%s could not be parsed", param), http.StatusBadRequest, nil)
	}
	return parseBool, nil
}

func QueryOptionalParamToBool(r *http.Request, param string) (*bool, error) {
	s := r.URL.Query().Get(param)
	if s != "" {
		parseBool, err := strconv.ParseBool(s)
		if err != nil {
			return nil, errors.New(errors.BusinessErrorCode, fmt.Sprintf("%s could not be parsed", param), http.StatusBadRequest, nil)
		}
		return &parseBool, nil
	}
	return nil, nil
}

func QueryOptionalParamToDateTime(r *http.Request, param string) (*time.Time, error) {
	s := r.URL.Query().Get(param)
	if s != "" {
		date, err := time.Parse(time.RFC3339, s)
		if err != nil {
			return nil, errors.New(errors.BusinessErrorCode, fmt.Sprintf("%s could not be parsed", param), http.StatusBadRequest, nil)
		}
		return &date, nil
	}
	return nil, nil
}

func QueryParamToDateTime(r *http.Request, param string) (time.Time, error) {
	date, err := time.Parse(time.RFC3339, r.URL.Query().Get(param))
	if err != nil {
		return time.Time{}, errors.New(errors.BusinessErrorCode, fmt.Sprintf("%s could not be parsed", param), http.StatusBadRequest, nil)
	}
	return date, nil
}

func QueryOptionalParamToInt32(r *http.Request, param string) (*int32, error) {
	s := r.URL.Query().Get(param)
	if s != "" {
		parseInt, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return nil, errors.New(errors.BusinessErrorCode, fmt.Sprintf("%s could not be parsed", param), http.StatusBadRequest, nil)
		}
		result := int32(parseInt)
		return &result, nil
	}
	return nil, nil
}

func QueryParamToInt32(r *http.Request, param string) (int32, error) {
	s := r.URL.Query().Get(param)
	parseInt, err := strconv.ParseInt(s, 10, 32)
	if err != nil {
		return 0, errors.New(errors.BusinessErrorCode, fmt.Sprintf("%s could not be parsed", param), http.StatusBadRequest, nil)
	}
	return int32(parseInt), nil
}

func QueryParamToArrayInt32(r *http.Request, param string) ([]int32, error) {
	arr := r.URL.Query()[param]
	res := make([]int32, len(arr))
	for i := range arr {
		parseInt, err := strconv.ParseInt(arr[i], 10, 32)
		if err != nil {
			return nil, errors.New(errors.BusinessErrorCode, fmt.Sprintf("%s could not be parsed", param), http.StatusBadRequest, nil)
		}
		res[i] = int32(parseInt)
	}
	return res, nil
}

func QueryParamToInt64(r *http.Request, param string) (int64, error) {
	s := r.URL.Query().Get(param)
	parseInt, err := strconv.ParseInt(s, 10, 64)
	if err != nil {
		return 0, errors.New(errors.BusinessErrorCode, fmt.Sprintf("%s could not be parsed", param), http.StatusBadRequest, nil)
	}
	return parseInt, nil
}

func QueryOptionalParamToInt64(r *http.Request, param string) (*int64, error) {
	s := r.URL.Query().Get(param)
	if s != "" {
		parseInt, err := strconv.ParseInt(s, 10, 64)
		if err != nil {
			return nil, errors.New(errors.BusinessErrorCode, fmt.Sprintf("%s could not be parsed", param), http.StatusBadRequest, nil)
		}
		return &parseInt, nil
	}
	return nil, nil
}

func QueryParamToArrayInt64(r *http.Request, param string) ([]int64, error) {
	arr := r.URL.Query()[param]
	res := make([]int64, len(arr))
	for i := range arr {
		parseInt, err := strconv.ParseInt(arr[i], 10, 64)
		if err != nil {
			return nil, errors.New(errors.BusinessErrorCode, fmt.Sprintf("%s could not be parsed", param), http.StatusBadRequest, nil)
		}
		res[i] = parseInt
	}
	return res, nil
}

// GetVersion returns version from requests query parameter version
func GetVersion(r *http.Request) sql.NullInt64 {
	v, err := strconv.ParseInt(QueryParamToString(r, "version"), 10, 64)
	version := sql.NullInt64{
		Int64: v,
		Valid: err == nil,
	}
	return version
}

func GetPageParams(r *http.Request) (page int32, size int32) {
	p, err := strconv.Atoi(r.URL.Query().Get("page"))
	if err != nil || p < 0 {
		p = 0
	}
	s, err := strconv.Atoi(r.URL.Query().Get("size"))
	if err != nil || s < 0 {
		s = 20
	}
	return int32(p), int32(s)
}

func CreatePage(content any, page int32, size int32, totalElements int64, sort []string) *dto.Page {
	contentType := reflect.ValueOf(content)
	var numberOfElements int
	if contentType.Kind() == reflect.Pointer {
		contentType = contentType.Elem()
	}
	if contentType.Kind() == reflect.Slice || contentType.Kind() == reflect.Array {
		numberOfElements = contentType.Len()
	}
	totalPages := int32(math.Ceil(float64(totalElements) / float64(size)))
	offset := page * size
	return &dto.Page{
		Pageable: dto.Pageable{
			Page:   page,
			Size:   size,
			Offset: offset,
		},
		Sort: dto.Sort{
			Empty:    len(sort) == 0,
			Sorted:   len(sort) != 0,
			Unsorted: len(sort) == 0,
		},
		Content:          content,
		Empty:            numberOfElements == 0,
		First:            page == 0,
		Last:             int32(page)+1 >= totalPages,
		NumberOfElements: int32(numberOfElements),
		Size:             int32(size),
		TotalElements:    totalElements,
		TotalPages:       totalPages,
	}
}
