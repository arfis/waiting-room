// Code generated by go generate; DO NOT EDIT.

package middleware

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log/slog"
	"math"
	"net/http"
	"strconv"
	"strings"

	appCtx "github.com/arfis/waiting-room/nghis-adapter/internal/context"
	"github.com/arfis/waiting-room/nghis-adapter/internal/errors"
	"github.com/arfis/waiting-room/nghis-adapter/internal/service"
)

const (
	TENANT_HEADER = "x-tenant-id"
	AUTH_HEADER   = "authorization"
	USER_INFO     = "x-user-info"
	Bearer        = "Bearer "
)

type User struct {
	EmployeeId string `json:"employeeId"`
}

type aud []string

func (a *aud) UnmarshalJSON(data []byte) error {
	var s []string
	if err := json.Unmarshal(data, &s); err != nil {
		var i string
		if err := json.Unmarshal(data, &i); err != nil {
			return err
		}
		s = []string{i}
	}
	*a = s
	return nil
}

type AuthToken struct {
	Jti               string   `json:"jti"`
	Exp               int64    `json:"exp"`
	Iss               string   `json:"iss"`
	Aud               aud      `json:"aud"`
	Sub               string   `json:"sub"`
	Typ               string   `json:"typ"`
	Scope             string   `json:"scope"`
	Tenant            int32    `json:"tenant"`
	PreferredUsername string   `json:"preferred_username"`
	User              User     `json:"user"`
	Name              string   `json:"name"`
	Groups            []string `json:"groups"`
	OriginalToken     string
}

func Authorization(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		authorizationHeader := r.Header.Get(AUTH_HEADER)

		if authorizationHeader == "" {
			authorizationHeader = r.Header.Get(USER_INFO)
		}

		var (
			ctx        context.Context = r.Context()
			tenantID64 int64
			tenantID   int32
			err        error
		)

		if authorizationHeader != "" {
			ctx, tenantID, err = prepareAuthContext(ctx, authorizationHeader)
			if err != nil {
				slog.ErrorContext(ctx, "problem preparing authorization context", "err", err)
				err := setBadRequestAuthError(w)
				if err != nil {
					slog.ErrorContext(ctx, "problem writing bad request auth error", "err", err)
				}
				return
			}
		}

		tenantHeader := r.Header.Get(TENANT_HEADER)
		if tenantHeader != "" {
			tenantID64, err = strconv.ParseInt(tenantHeader, 10, 64)
			if err != nil {
				slog.ErrorContext(ctx, "problem retrieving tenant", "err", err)
				err := setBadRequestTenantError(w)
				if err != nil {
					slog.ErrorContext(ctx, "problem writing bad request tenant error", "err", err)
				}
				return
			}
			// Add range check before clamping
			if tenantID64 > math.MaxInt32 || tenantID64 < 1 {
				slog.ErrorContext(ctx, "tenant ID out of valid range", "value", tenantID64)
				err := setBadRequestTenantError(w)
				if err != nil {
					slog.ErrorContext(ctx, "problem writing bad request tenant error", "err", err)
				}
				return
			}
			tenantID = service.SafeInt64ToInt32(tenantID64)
		}

		if tenantID == 0 {
			slog.ErrorContext(ctx, "problem retrieving tenant", "err", err)
			err := setBadRequestTenantError(w)
			if err != nil {
				slog.ErrorContext(ctx, "problem writing bad request tenant error", "err", err)
			}
			return
		}

		next.ServeHTTP(w, r.WithContext(context.WithValue(ctx, appCtx.TENANT, tenantID)))
	})
}

func prepareAuthContext(ctx context.Context, authorizationHeader string) (context.Context, int32, error) {
	// Accept both "Bearer <jwt>" and raw "<jwt>" (e.g., x-user-info)
	authorizationHeaderTruncated := strings.TrimPrefix(authorizationHeader, Bearer)
	authHeaderParts := strings.Split(authorizationHeaderTruncated, ".")
	if len(authHeaderParts) != 3 {
		return nil, 0, fmt.Errorf("wrong format of authorization header")
	}

	tokenBytes, err := base64.URLEncoding.WithPadding(base64.NoPadding).DecodeString(authHeaderParts[1])
	if err != nil {
		return nil, 0, fmt.Errorf("cannot decode authorization token %w", err)
	}

	var token AuthToken
	err = json.Unmarshal(tokenBytes, &token)
	if err != nil {
		return nil, 0, fmt.Errorf("cannot unmarshal authorization token %w", err)
	}

	token.OriginalToken = authorizationHeader
	ctx = context.WithValue(ctx, appCtx.ORIGINAL_TOKEN, token.OriginalToken)

	if token.PreferredUsername != "" {
		ctx = context.WithValue(ctx, appCtx.LOGIN, token.PreferredUsername)
	}
	if token.Sub != "" {
		ctx = context.WithValue(ctx, appCtx.SUB, token.Sub)
	}
	if token.Name != "" {
		ctx = context.WithValue(ctx, appCtx.USERNAME, token.Name)
	}

	if token.Tenant < 1 {
		return nil, 0, fmt.Errorf("authorization token must contain valid tenant identifier")
	}

	return ctx, token.Tenant, nil
}

func setBadRequestTenantError(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusForbidden)
	payloadBytes, err := json.Marshal(errors.New(errors.MissingTenantCode, "cannot retrieve tenant", http.StatusForbidden, nil))
	if err != nil {
		return err
	}
	_, err = w.Write(payloadBytes)
	return err
}

func setBadRequestAuthError(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusUnauthorized)
	payloadBytes, err := json.Marshal(errors.New(errors.AuthHeaderCode, "authorization header has wrong format", http.StatusUnauthorized, nil))
	if err != nil {
		return err
	}
	_, err = w.Write(payloadBytes)
	return err
}
