package utils

import (
	"bytes"
	"fmt"
	"go/format"
	"log/slog"
	"os"
	"strconv"
	"strings"
	"text/template"

	"gitlab.com/soluqa/bookio/service-generator/internal"
)

func ToPublic(s string) string {
	return strings.ToUpper(s[:1]) + s[1:]
}

func ToPrivate(s string) string {
	return strings.ToLower(s[:1]) + s[1:]
}

func Quote(s string) string {
	return strconv.Quote(s)
}

func CreateTemplate(t string) *template.Template {
	funcMap := template.FuncMap{
		"ToPublic":  ToPublic,
		"ToPrivate": ToPrivate,
		"Quote":     Quote,
	}
	return template.Must(template.New("").Funcs(funcMap).Parse(t))
}

var skippedFiles = make([]string, 0)

// ForceSave overwrites the file if it exists with provided data
// does not save if file exists and generated comment has been removed
func ForceSave(path string, data []byte) {
	f, err := os.Open(path)
	if err == nil {
		b := make([]byte, 46)
		_, err = f.ReadAt(b, 0)
		if err != nil {
			slog.Error("cannot read", "file", path, "err", err)
			err = f.Close()
			if err != nil {
				slog.Error("cannot close", "file", path, "err", err)
			}
			os.Exit(1)
		}

		err = f.Close()
		if err != nil {
			slog.Error("cannot close", "file", path, "err", err)
		}

		if string(b) != "// Code generated by go generate; DO NOT EDIT." {
			skippedFiles = append(skippedFiles, path)
			return
		}
	}

	formatted, err := format.Source(data)
	if err != nil {
		slog.Error("cannot format source", "file", path, "err", err)
		slog.Error(string(data))
		os.Exit(1)
	}

	ForceSavePlain(path, formatted)
}

// ForceSavePlain overwrites the file if it exists with provided data, does not format code
// use for non go files
func ForceSavePlain(path string, data []byte) {
	slog.Info("saving...", "file", path)
	err := os.WriteFile(path, data, internal.FilePerm)
	if err != nil {
		slog.Error("error saving file", "file", path, "err", err)
		os.Exit(1)
	}
}

// ForceSavePlainOrSkip overwrites the file if it exists with provided data, does not format code
// use for non-go files. Skips files where generated comment has been removed.
func ForceSavePlainOrSkip(path string, data []byte) {
	f, err := os.Open(path)
	if err == nil {
		b := make([]byte, 46)
		_, err = f.ReadAt(b, 0)
		if err != nil {
			slog.Error("cannot read", "file", path, "err", err)
			err = f.Close()
			if err != nil {
				slog.Error("cannot close", "file", path, "err", err)
			}
			os.Exit(1)
		}

		err = f.Close()
		if err != nil {
			slog.Error("cannot close", "file", path, "err", err)
		}

		if !strings.Contains(string(b), "Code generated by go generate; DO NOT EDIT") {
			slog.Info("skipping... (generated comment missing)", "file", path)
			skippedFiles = append(skippedFiles, path)
			return
		}
	}

	slog.Info("saving...", "file", path)
	err = os.WriteFile(path, data, internal.FilePerm)
	if err != nil {
		slog.Error("error saving file", "file", path, "err", err)
		os.Exit(1)
	}
}

func CreateDir(wd string, path string) {
	slog.Info("creating directory", "workdir", wd, "path", path)
	err := os.MkdirAll(fmt.Sprintf("%s/%s", wd, path), internal.DirPerm)
	if err != nil {
		slog.Error("error creating directory", "workdir", wd, "path", path)
		os.Exit(1)
	}
}

// Save returns true if the file was created
func Save(path string, data []byte) bool {
	_, err := os.ReadFile(path)
	if err != nil {
		ForceSave(path, data)
		return true
	}
	slog.Info("already exists", "path", path)
	return false
}

// SavePlain Save returns true if the file was created, does not format code
func SavePlain(path string, data []byte) bool {
	_, err := os.ReadFile(path)
	if err != nil {
		ForceSavePlain(path, data)
		return true
	}
	slog.Info("already exists", "path", path)
	return false
}

func ExecuteAndFormat(template *template.Template, data interface{}) []byte {
	var buf bytes.Buffer
	err := template.Execute(&buf, data)
	if err != nil {
		slog.Error("error executing template", "err", err)
		os.Exit(1)
	}
	source, err := format.Source(buf.Bytes())
	if err != nil {
		slog.Error("error formatting source", "err", err)
		os.Exit(1)
	}
	return source
}

func Execute(template *template.Template, data interface{}) []byte {
	var buf bytes.Buffer
	err := template.Execute(&buf, data)
	if err != nil {
		slog.Error("error executing template", "err", err)
		os.Exit(1)
	}

	return buf.Bytes()
}
