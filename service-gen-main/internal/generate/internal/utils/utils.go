package utils

import (
	"fmt"

	"gitlab.com/soluqa/bookio/service-generator/internal/utils"
)

func Generate(wd string, module string) {
	ptrUtils := utils.ExecuteAndFormat(ptrUtilsT, nil)
	utils.CreateDir(wd, "internal/utils/ptr")
	utils.ForceSave(fmt.Sprintf("%s/internal/utils/ptr/ptr.go", wd), ptrUtils)
	utils.ForceSave(fmt.Sprintf("%s/internal/utils/arrays.go", wd), utils.ExecuteAndFormat(arrUtilsT, nil))
}

var ptrUtilsT = utils.CreateTemplate(`
// Code generated by go generate; DO NOT EDIT.
package ptr

func Ptr[T any](val T) *T {
	return &val
}

func IsNil[T any](data *T) bool {
	return data == nil
}

func IsNotNil[T any](data *T) bool {
	return !IsNil(data)
}

func ValueDefault[T any](data *T, defaultValue T) T {
	if data == nil {
		return defaultValue
	}
	return *data
}
`)

var arrUtilsT = utils.CreateTemplate(`
// Code generated by go generate; DO NOT EDIT.
package utils

func Contains[T comparable](elements []T, v T) bool {
    for _, s := range elements {
        if v == s {
            return true
        }
    }
    return false
}

func Any[T comparable](elements[]T, v ...T) bool {
    l := len(v)
    if l == 0 {
        return false
    }

    if l == 1 {
        return Contains[T](elements, v[0])
    }

    m := make(map[T]any)
    for _, e := range elements {
        m[e] = struct{}{}
    }

    for _, a := range v {
        if _, ok := m[a]; ok {
            return true
        }
    }
    return false
}

func Remove[T comparable](elements []T, index int) []T {
	return append(elements[:index], elements[index+1:]...)
}

func RemoveByValue[T comparable](elements []T, value T) []T {
	for i := 0; i < len(elements); i++ {
		if value == elements[i] {
			elements = Remove(elements, i)
			i--
		}
	}
	return elements
}
`)
