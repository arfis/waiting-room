# Table of contents

1. [Generator](#service-gen)
   1. [Arguments](#arguments)
   2. [Usage](#usage)
2. [OpenAPI](#openapi-custom-properties)
   1. [Server configuration](#server-configuration)
   2. [Modules](#modules)
   3. [Components](#components)
      1. [DTO](#dto)
      2. [Custom types](#custom-types)
3. [Generated Application](#generated-application)
   1. [App configuration](#app-configuration)
   2. [Rest clients](#rest-clients)
   4. [Testing](#testing)
4. [SQL Transactions](#sql-transactions)

# service-generator

Will perform service generation on provided OpenAPI specification.

## arguments

- wd - working directory. Directory where service will be generated
- open-api - OpenAPI file used for service generation

Examples for OpenAPI definitions can be found in [examples](./examples)

<span style="color:red">Every file that is re-generated is marked as</span>

```golang
// Code generated by go generate; DO NOT EDIT.
```

Changes to these files will be lost when generator runs again.

## usage

Install service-gen locally by checking out the project and then running

```bash
go install ./cmd/service-generator
```

inside the git repository or

```bash
go install gitlab.com/soluqa/bookio/service-generator.git
```

To Generate a service using generator run

```bash
service-generator -wd ./ -open-api ./open-api.yaml
```

in a directory you want to generate the service in.

# OpenAPI custom properties

```text
path.operationId - specifies name of the function that will be generated to handle request
path.x-generated.customHandler - a boolean, when true custom handler is used, else it's generated
path.x-generated.package - package in which code should be generated
```

### property validations
In order to add validation tags into properties of generated structs, property "x-validate" which accept array of validation rules can be used.

Validator built-in validation tags can be found here: https://github.com/go-playground/validator

Definition
```yaml
RegisterReq:
  x-group: parameter
  title: ParameterFilterReq
  type: object
  required:
    - email
  properties:
    phoneNumber:
      x-validate:
         - e164
      type: string
    email:
      x-validate:
        - email
      type: string
```
Would generate following code:
```go
type RegisterReq struct {
	email *string "json:\"email\", validate:\"required,email\""
	phoneNumber *string "json:\"phoneNumber\", validate:\"e164\""
}
```

### application error

Every error returned from our API should be specifically defined as `ApplicationError` and should have this structure:

```yaml
ApplicationError:
   x-group: errors
   title: ApplicationError
   type: object
   description: The same type for all errors returned from API.
   required:
    - text
    - code
   properties:
    text:
       type: string
    code:
       type: string
       enum:
          - BUSINESS_ERROR
          - VALIDATION_ERROR
          - MISSING_REQUIRED_FIELD_ERROR
          - OBJECT_VERSION_MISMATCH_ERROR
          - NOT_FOUND_ERROR
          - SERVICE_CALL_ERROR
          - FORBIDDEN_ERROR
          - INTERNAL_SERVER_ERROR
          - AUTH_HEADER
          - UNPROCESSABLE_ENTITY_FOREIGN_KEY
          - UNPROCESSABLE_ENTITY_UNIQUE
```

Codes are returned as an enum and should match the common codes defined in the package `errors`. The usage in openAPI should then be:

```yaml
/some-endpoint:
  post:
    
     ...
    
     responses:
        "200":
           content:
              application/json:
                 schema:
                    $ref: "#/components/schemas/Response"
           description: OK
        "400":
           content:
              application/json:
                 schema:
                    $ref: '#/components/schemas/ApplicationError'
           description: validation errors
        "404":
           content:
              application/json:
                 schema:
                    $ref: '#/components/schemas/ApplicationError'
           description: not found errors
        "500":
           content:
              application/json:
                 schema:
                    $ref: '#/components/schemas/ApplicationError'
           description: internal errors
     ...
```

This makes the contract straight-forward for success response and for the error responses too.

There is a validation that you properly set the code enums in the definition of the error according to the common error codes in `errors` package.

When using `values` in you errors, the contract can be defined like this:

```yaml
ApplicationError:
   x-group: errors
   title: ApplicationError
   type: object
   description: The same type for all errors returned from API.
   required:
    - text
    - code
   properties:
    text:
       type: string
    code:
       type: string
       enum:
          - BUSINESS_ERROR
          - VALIDATION_ERROR
          - MISSING_REQUIRED_FIELD_ERROR
          - OBJECT_VERSION_MISMATCH_ERROR
          - NOT_FOUND_ERROR
          - SERVICE_CALL_ERROR
          - FORBIDDEN_ERROR
          - INTERNAL_SERVER_ERROR
          - AUTH_HEADER
          - UNPROCESSABLE_ENTITY_FOREIGN_KEY
          - UNPROCESSABLE_ENTITY_UNIQUE
    values:
       $ref: '#/components/schemas/ApplicationErrorValues'
ApplicationErrorValues:
    x-group: errors
    title: ApplicationErrorValues
    type: object
    properties:
       # here just define the fields according to your custom values you will use...
       additionalCode:
          type: string
       additionalMessage:
          type: string
```

If you use `custom errors` (see below), you should specify the code(s) properly in your openAPI contract in the error definition. If you don't, there is a validation that will force you to. Example:

```yaml
openapi: 3.0.0
info:
   title: some app

...

x-errors:
   NAME_TOO_SHORT:
      description: "Validates that the name is 10 characters or longer."
      message: "The provided name is too short."
      httpCode: 400
      
...

ApplicationError:
   x-group: errors
   title: ApplicationError
   type: object
   description: The same type for all errors returned from API.
   required:
      - text
      - code
   properties:
      text:
         type: string
      code:
         type: string
         enum:
            - BUSINESS_ERROR 
            - VALIDATION_ERROR
            - MISSING_REQUIRED_FIELD_ERROR
            - OBJECT_VERSION_MISMATCH_ERROR
            - NOT_FOUND_ERROR
            - SERVICE_CALL_ERROR
            - FORBIDDEN_ERROR
            - INTERNAL_SERVER_ERROR
            - INTERNAL_SERVER_ERROR
            - AUTH_HEADER
            - UNPROCESSABLE_ENTITY_FOREIGN_KEY
            - UNPROCESSABLE_ENTITY_UNIQUE # these and above are common errors from errors package
            - NAME_TOO_SHORT # this is your custom error and needs to be defined here too
```

### custom errors
To specify a custom business error that is going to be used in endpoint there is a property `x-errors`. It contains a map of errors where the key is the error code.

You need to provide at least HTTP return code and message for each error.

Basic example:

```yaml
openapi: 3.0.0
info:
   title: some app

...

x-errors:
   SOMETHING_WENT_WRONG:
      httpCode: 424
      message: "Something went wrong."
   WE_DONT_LIKE_SPINACH:
      httpCode: 500
      message: "This really is not our taste."
      
paths:
   /some-endpoint:
      get:

...
```

All the errors specified in the openAPI are generated to the file generated.go in the package errors like this:

```go
// Code generated by go generate; DO NOT EDIT.
package errors

const (
   SomethingWentWrongCode = "SOMETHING_WENT_WRONG"
   WeDontLikeSpinachCode  = "WE_DONT_LIKE_SPINACH"
)

// SomethingWentWrong custom error.
func SomethingWentWrong() *ApplicationError {
   return New(SomethingWentWrongCode, "Something went wrong.", 424, nil)
}

// WeDontLikeSpinach custom error.
func WeDontLikeSpinach() *ApplicationError {
   return New(WeDontLikeSpinachCode, "This really is not our taste.", 500, nil)
}
```

Usage:

```go
func (s *Service) ListOpenEHR(ctx context.Context, req *dto.OpenEHRListReq) (*dto.OpenEHRListResp, error) {
	...
	
	return nil, appErrors.WeDontLikeSpinach()
}
```

You can also set the description:

```yaml
openapi: 3.0.0
info:
   title: some app

...

x-errors:
   SOMETHING_WENT_WRONG:
      httpCode: 424
      message: "Something went wrong."
      description: "You can specify the purpose or any details of this error here." # this will generate doc comment in the source code
      
paths:
   /some-endpoint:
      get:

...
```

By setting the property `hasValues` to `true` you can also generate the error with additional values you can pass to the output. Example:

```yaml
openapi: 3.0.0
info:
   title: some app

...

x-errors:
   SOMETHING_WENT_WRONG:
      httpCode: 424
      message: "Something went wrong."
      description: "You can specify the purpose or any details of this error here."
      hasValues: true
      
paths:
   /some-endpoint:
      get:

...
```

This will generate:

```go
// SomethingWentWrong - You can specify the purpose or any details of this error here.
func SomethingWentWrong(values map[string]any) *ApplicationError {
    return New(SomethingWentWrongCode, "Something went wrong.", 424, values)
}
```

and can be used like this:

```go
func (s *Service) ListOpenEHR(ctx context.Context, req *dto.OpenEHRListReq) (*dto.OpenEHRListResp, error) {
	...
	
	return nil, appErrors.SomethingWentWrong(map[string]any{"details": "some details", "sourceErrorMessage": "some source error message"})
}
```

You also can set the placeholder in your message like this:

```yaml
openapi: 3.0.0
info:
   title: some app

...

x-errors:
   VALIDITY_ERROR:
      httpCode: 400
      message: "Field %s is invalid."
      
paths:
   /some-endpoint:
      get:

...
```

This will generate an error with the input:

```go
// ValidityError custom error.
func ValidityError(params ...any) *ApplicationError {
    return New(ValidityErrorCode, fmt.Sprintf("Field %s is invalid.", params...), 400, nil)
}
```

### server configuration

```yaml
x-configuration:
  shortname: register # name of the service being generated
  module: git.prosoftke.sk/nghis/services/register/register-service # module path
```

#### api

Specifies which executable should contain generated endpoints from open-api spec. Executables without this module will provide only custom and metrics ednpoints.

## Components

### DTO

All components in components.schemas will be generated
in dto package. Enum have their own package assigned to prevent overlapping.
There is no need to specify x-group attribute due to the fact that
enums will be generated in their own package based on their names.

```yaml
components.schemas.<component>.x-group
x-group: attribute  #marks file where component will be generated 
```

#### XML
We're supporting xml tags for open-api components. Please refer to open-api specification for the details. Example usage

```yaml
    AppointmentResp:
      x-group: appointment
      title: AppointmentResp
      type: object
      required:
        - id
      properties:
        id:
          format: int64
          type: integer
          xml:
            name: "appointment-id"
            attribute: true
        name:
          type: string
          xml:
            name: "Meno"
            prefix: "v6"
        cancellation:
          format: date-time
          type: string
        canceled:
          type: boolean
        period:
          $ref: "#/components/schemas/Validity"
        serviceRequest:
          format: int64
          type: integer
        status:
          $ref: "#/components/schemas/AppointmentStatus"
        serviceResource:
          format: int64
          type: integer
        urgency:
          type: string
        locked:
          type: string
        massEventCapacity:
          format: int64
          type: integer
        calendarPeriods:
          type: array
          items:
            $ref: '#/components/schemas/CalendarPeriodResp'
        ongoingEvents:
          type: array
          items:
            $ref: '#/components/schemas/OngoingEventResp'
        labels:
          type: array
          items:
            $ref: '#/components/schemas/LabelResp'
      xml:
        prefix: "vzp"
        name: "AppointmentOdpoved"
```

So from this you can expect a xml document like this:

```xml
<vzp:AppointmentOdpoved appointment-id="id">
    <v6:Meno>Meno</v6:Meno>
...
</vzp:AppointmentOdpoved>
```

Important detail to note is that if you don't specify the xml name of the component, like `AppointmentOdpoved` in this case, no xml tags will be generated for the structure.
So you can understand this as a trigger for xml tags. If you don't specify xml names for the properties, but do for the component, we will use the property names as the element
names by default. So the above example will be serialized like this:

```xml
<vzp:AppointmentOdpoved appointment-id="id">
    <v6:Meno>Meno</v6:Meno>
    <cancellation></cancellation>
    <canceled></canceled>
    <period></period>
    <serviceRequest></serviceRequest>
    <status></status>
    <serviceResource></serviceResource>
    <urgency></urgency>
    <locked></locked>
    <massEventCapacity></massEventCapacity>
    <calendarPeriods></calendarPeriods>
    <ongoingEvents></ongoingEvents>
    <labels></labels>
</vzp:AppointmentOdpoved>
```

### Custom types

```yaml
type: string
format: date
```
produces LocalDate type and cosumes format YYYY-MM-DD


```
type: string
format: time
```
produces LocalTime type and cosumes format hh-mm-ss

```
type: string
format: local-date-time
```
produces LocalDateTime type and cosumes format YYYY-MM-DDThh-mm-ss

# Generated Application

Application uses:

- Chi as web router github.com/go-chi/chi
- Configuration with ENV using github.com/ilyakaznacheev/cleanenv
- Logging using standard log/slog
- DB schema migrations using github.com/golang-migrate/migrate

Application uses code generated by service-gen marked as generate by a comment
`// Code generated by go generate; DO NOT EDIT.` on first line.
These files will be regenerated with each execution of service-gen.
Then there are files that are generated at first but generator
will not touch them once they are present.

## App configuration

Application configuration can be added into `/internal/config/application.go`
file and used in code by using Conf variable of config package. 

You can initialize parts of application on startup using `internal/hooks/hooks.go`

## Rest clients

Rest clients are generated using open-api.

```yaml
x-configuration:
  clients: 
    - nghispatientclient
```

Generator will generate a variable inside client package for
each client specified. Clients can be configured using

```yaml
clients:
  nghispatientclient:
    host: api.dev.nghis.prosoftke.sk
    scheme: https
    context: patient-management
```

If there is a client generated and its missing configuration, service
will fail to start and will print error to stderr.

## HTTP Server
In Generator v2, which we are currently using, the HTTP server is no longer created automatically. 
You need to create an instance of HTTP server manually.

You can see an example below:
```golang
func NewServer(
	configuration *service.Configuration,
	tracing *opentelemetry.TracingGrpc,
	loggingMiddleware *middleware.LoggingMiddleware,
	diContainer *dig.Container,
) *http.Server {
	r := chi.NewRouter()
	r.Route(configuration.ServerContext, func(router chi.Router) {
		router.Use(middleware.Authorization)
		router.Use(opentelemetry.NewHTTPMiddleware(configuration.ServiceName, configuration.ServiceInstanceName, tracing).Middleware())
		router.Use(chimiddleware.Compress(5))
		router.Use(chimiddleware.Timeout(configuration.HttpTimeout))
		router.Use(middleware.RequestIdMiddleware)
		router.Use(loggingMiddleware.LoggingMiddleware)
		router.Use(middleware.Cors())
		register.Generated(router, diContainer)
	})
	http.Handle("/", r)

	return &http.Server{
		Addr:              ":" + configuration.ServerPort,
		Handler:           r,
		ReadHeaderTimeout: 2 * time.Second, // mitigate slow loris attack
	}
}
```
As of **25/6/2024**, we have removed the custom timeout definition per handler and also the pre-generated timeout for 
handlers with a default value of 60 seconds.

To set the timeout, you need to set timeout middleware on the Chi router when creating a new instance of the HTTP Server. 
Ideally, the timeout should be defined in the environment variables and not hardcoded.

_Before:_
```golang
r.With(chimiddleware.Timeout(60*time.Second)).Post("/employee", employeeHandler.CreateEmployee)
r.With(chimiddleware.Timeout(60*time.Second)).Delete("/employee/{id}", employeeHandler.DeleteEmployee)
```

_After:_
```golang
r.Post("/employee", employeeHandler.CreateEmployee)
r.Delete("/employee/{id}", employeeHandler.DeleteEmployee)
```

## Testing

Generator will generate files:

- base.go - contains helper functions for testing (regenerated)
- main_test.go - contains test initialization (regenerated)
- data.go - data initialization (file is not regenerated)

For testing rest client calls use [gock](https://github.com/h2non/gock)

Example:

```go
package test

import (
...
  "mymodule/internal/client"
...
)
func Test_ListAttributes(t *testing.T) {
  defer gock.Off()
  gock.InterceptClient(client.GetHttpClient())

  gock.New("http://localhost/mockedservice").
    Get("resource").
    Reply(200).
    JSON("{\"size\":1}")
    
  request(t, "GET", fmt.Sprintf("%s/service-request", baseUrl), nil)

  gock.IsDone()
}
```

## Errors

Generator generates two structures of errors ApplicationError and ErrorWithStack located in 
package errors with helper functions to easily create them.



# FAQ

#### Can overwrite a file that is being generated by generator?

Yes you can remove top line with comment
```go
// Code generated by go generate; DO NOT EDIT.
```
and generator will skip this file during next run.

