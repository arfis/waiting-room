// Code generated by go generate; DO NOT EDIT.
package errors

import (
	"errors"
	"fmt"
	"net/http"

	"github.com/go-playground/validator/v10"
)

const (
	NotFoundErrorMessage             = "entity was not found"
	ForeignKeyConstraintErrorMessage = "entity violates foreign key constraint"
	UniqueConstraintErrorMessage     = "entity violates unique constraint"
)

type ErrorValues map[string]any

type ApplicationError struct {
	Code     string      `json:"code"`
	Text     string      `json:"text"`
	HttpCode int         `json:"-"`
	Values   ErrorValues `json:"values,omitempty"`
}

func Business(err error, values ErrorValues) *ApplicationError {
	return NewError(err, BusinessErrorCode, http.StatusBadRequest, values)
}

func System(err error, values ErrorValues) *ApplicationError {
	return NewError(err, InternalServerErrorCode, http.StatusInternalServerError, values)
}

func Validation(err error, values ErrorValues) *ApplicationError {
	return NewError(err, ValidationErrorCode, http.StatusBadRequest, values)
}

// RequestValidation adds - based on validator.ValidationErrors -
// metadata about errors in specific fields into the error.
func RequestValidation(err error) *ApplicationError {
	var validationErrors validator.ValidationErrors
	if errors.As(err, &validationErrors) {
		invalidFields := make(map[string]any)
		for _, validationError := range validationErrors {
			invalidFields[validationError.StructNamespace()] = validationError.Tag()
		}

		return Validation(err, invalidFields)
	}

	return Validation(err, nil)
}

func ServiceCall(err error, values ErrorValues) *ApplicationError {
	return NewError(err, ServiceCallErrorCode, http.StatusFailedDependency, values)
}

func Forbidden(text string, values ErrorValues) *ApplicationError {
	return New(ForbiddenErrorCode, text, http.StatusForbidden, values)
}

func NotFound(err error, values ErrorValues) *ApplicationError {
	return NewError(err, NotFoundErrorCode, http.StatusNotFound, values)
}

// EntityNotFound is useful if we want to return 404 and we do not want to
// pass e.g. SQL error message to the output (to avoid sensitive data leak).
func EntityNotFound() *ApplicationError {
	return New(NotFoundErrorCode, NotFoundErrorMessage, http.StatusNotFound, nil)
}

// ForeignKeyConstraint is useful if we want to return 422 in the case
// of e.g. updating entity to non-existing foreign key.
func ForeignKeyConstraint() *ApplicationError {
	return New(UnprocessableEntityForeignKeyCode, ForeignKeyConstraintErrorMessage, http.StatusUnprocessableEntity, nil)
}

// UniqueConstraint is useful if we want to return 422 in the case
// of e.g. updating entity violating unique constraint.
func UniqueConstraint() *ApplicationError {
	return New(UnprocessableEntityUniqueCode, UniqueConstraintErrorMessage, http.StatusUnprocessableEntity, nil)
}

func New(code, text string, httpCode int, values ErrorValues) *ApplicationError {
	return &ApplicationError{
		Code:     code,
		Text:     text,
		HttpCode: httpCode,
		Values:   values,
	}
}

func NewError(err error, code string, httpCode int, values ErrorValues) *ApplicationError {
	return &ApplicationError{
		Code:     code,
		Text:     err.Error(),
		HttpCode: httpCode,
		Values:   values,
	}
}

func FromError(err error) (*ApplicationError, bool) {
	if err == nil {
		return nil, true
	}
	var appErr *ApplicationError
	if errors.As(err, &appErr) {
		return appErr, true
	}
	return Business(err, nil), false
}

func (e *ApplicationError) Error() string {
	return fmt.Sprintf("code: %s text: %s, status: %d values: %+v", e.Code, e.Text, e.HttpCode, e.Values)
}
